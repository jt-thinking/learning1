find ./-name *.txt 查找当前目录下所有txt文件

\b 单词边际
    \bis\b


{3} 重复3次

[/-]  / 或 -    尖括号就表示 '或'


GEGEXP 对比
	javaScript 通过内置对象RegExp 支持正则表达式
		有两种方法实例化 RegExp 对象
			1、字面量
				var reg = /\bis\b/    (如果是/\bis\b/g  加上一个g,代表全文搜索匹配, 否则只是匹配第一个)
				'He is a body . This is a dog.Where is she ?'.replace(reg,'IS')

			2、构造函数
				var reg = new RegExp('\\bis\\b','g')   这里使用\\    \  是因为在js中 \也属于特殊字符,要使用的话也要进行转义

		正则表达式修饰符
		
		g : global 全文搜索 , 不添加 , 搜索到第一个匹配停止
		i : ignore case 忽略大小写 , 默认大小写敏感
		m ： multiple lines 多行搜索	



元字符	
	正则表达式由两种基本字符类型组成 ：
		1、原义文本字符
		2、元字符
			在正则表达式中有特殊含义的非字母字符
				比如  . * + ? $ ^ | \ () {} [] 等
				另外	\t 水平制表符 
						\v 垂直制表符
						\n 换行符
						\r 回车符
						\0 空字符
						\f 换页符
						\cX 与X对应的控制字符(Ctrl + X)



字符类
	一般情况下正则表达式一个字符对应字符串一个字符
		表达式ab\t的含义是 “ab”  +  tab (0x09)

	字符类
		我们可以使用元字符[] 来构建一个简单的类 ,所谓的类是指符合某些特性的对象, 一个泛指, 而不是特指某个字符
			表达式[abc]把字符a或者b或者c 归为一类, 表达式可以匹配这类的字符

		字符类取反
			使用元字符^ 创建 反向类/负向类
				反向类的意思是不属于某类的内容
					表达式[^abc]表示不是字符a或b或c的内容



范围类
	我们还可以使用[a-z]来连接这两个字符表示从a到z的任意字符,包含a和z本身
		在[]组成的类内部是可以连写的[a-zA-Z]					



预定义类
	字符 	等价类 			含义
	.		[^\r\n]			除了回车符和换行符之外的所有字符
	\d 		[0-9]  			数字字符
	\D  	[^0-9]  		非数字字符
	\s 		[\t\n\x0B\f\r] 	空白符
	\S 		[^\t\n\x0B\f\r] 非空白符
	\w  	[a-zA-Z_0-9] 	单词字符(数字、字母、下划线)
	\W 		[……a-zA-Z_0-9]	非单词字符

边界
	字符 	含义
	^ 		以xxx开始
	$  		以xxx结束
	\b 		单词边界	/\bis\b/		
	\B 		非单词边界 	/\Bis\b/


量词
	字符 	含义
	?  		出现0次或者1次(最多出现1次)
	+   	出现1次或者多次(至少出现一次)
	*		出现0次或者多次(任意次)
	{n}		出现n次
	{n,m} 	出现n到m次
	{n,} 	至少出现n次


贪婪模式
	尽可能多的匹配 \d{3,6}

非贪婪模式
	让正则经可能少的匹配,也就是说一旦成功匹配不再继续尝试就是非贪婪模式
		做法很简单,在量词后面加上? 即可

分组
	匹配字符串Byron 连续出现3次的场景
		用() 可以达到分组的功能，使量词作用于分组
			{Byron}{3}

	反向引用
		'2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2$3$1')

	忽略分组
		不希望捕获某些分组,只需要在分组内加上 ?: 就可以了
			(?:Byron).(ok)

或
	使用 | 可以达到 或 的效果
		Byron | Casper
		Byr(on | Ca)sper

